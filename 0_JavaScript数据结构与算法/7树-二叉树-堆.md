## 树 (Tree)
- 一种以节点（node）为单位的抽象数据结构。
- 有一个根节点（root），其余节点通过“父-子”关系组织成分层结构。
- 其余节点分为互不相交的有限集T1、T2……Tm，每个集合又是一颗树：原来树的子树。
- 树是无环连通的有向结构（从根到子方向）。
  - `节点（node）`：包含数据（key/value）和指向子节点的引用（指针或索引）。
  - `父节点 / 子节点 |（parent / child）`：若节点 A 指向节点 B，则 A 为 B 的父节点，B 为 A 的子节点。
  - `叶子节点（leaf）`：没有子节点的节点。
  - `内部节点（internal node）`：至少有一个子节点的节点。
  - `度（degree）`：一个节点的子节点数量。整棵树的度是各个节点的最大度。
  - `高度（height）`：从某节点到其最深叶子的最长边数；树的高度 = 根节点的高度。
  - `深度（depth）` / `层（level）`：从根到该节点所经过的边数；根深度为 0（或 1，视约定）。
  - `子树（subtree）`：任一节点及其所有后代形成的树。
  - `路径（path）`：节点序列，每对相邻节点为父-子关系。

## 二叉树（Binary Tree）
- 每个节点最多有两个子节点（通常称为 left 和 right）。
- 二叉树是最常见的树型结构，简单但非常强大（可表示表达式树、堆、BST 等）
  - `满二叉树（Full / Strict）`：每个节点要么有 0 个子节点，要么恰好有 2 个子节点。
  - `完全二叉树（Complete）`：除了最底层，所有层都被填满；最底层的节点尽可能靠左。
  - `完美二叉树（Perfect）`：每一层都被完全填满（节点数 = 2^(h+1)-1）。
  - `平衡二叉树（Balanced）`：左右子树高度差被限制（例如 AVL：任一节点左右高度差 ≤ 1）。
  - `斜树 / 退化树 |（Skewed / Degenerate）`：每个节点只有一个子节点（类似链表）。
  - `⭐️二叉搜索树（BST）`：对于任意节点，左子树所有节点的值 < 节点值 ≤（或 <）右子树所有节点的值 —— 这个性质使得查找、插入、删除可高效完成（平均 O(log n)）。
- `遍历（Traversal）`：对树进行“访问所有节点”的策略。二叉树常见的有 4 种：
  - 前序（Preorder）：visit → left → right
  - 中序（Inorder）：left → visit → right | `⭐️ 对 BST，中序遍历会输出有序序列（升序）。`
  - 后序（Postorder）：left → right → visit
  - 层序（Level-order / `⭐️ BFS`）：按层从上到下、从左到右，通常用队列实现。｜`BFS：广度优先遍历 / 层序遍历`
    ```
        示例树：
            1
           / \
          2   3
         / \   \
        4   5   6
        前序：1 2 4 5 3 6
        中序：4 2 5 1 3 6
        后序：4 5 2 6 3 1
        层序：1 2 3 4 5 6
    ```

## 堆
- 堆是一个 “半有序树结构”，常用于实现`优先队列（Priority Queue）`、`排序算法`等。
- 结构上：`完全二叉树`（⚙️ 除了最后一层外，其它层都是满的；最后一层从左到右连续填充）
- 顺序上：
  - 最大堆（Max Heap）：每个节点的键值 ≥ 子节点键值 → 根节点最大
  - 最小堆（Min Heap）：每个节点的键值 ≤ 子节点键值 → 根节点最小
    ```
        示例最大堆：
            10
           /  \
          7    8
         / \  / \
        5  6  3  2
    ```
- 这种结构的代价是：
  - 堆只在根节点位置知道全局最小（或最大）值。
  - 其他位置的节点，只能保证「局部有序」，并不能直接确定全局的顺序。